/*! RowReorder 1.2.7
 * 2015-2020 SpryMedia Ltd - datatables.net/license
 */

/**
 * @summary     RowReorder
 * @description Row reordering extension for DataTables
 * @version     1.2.7
 * @file        dataTables.rowReorder.js
 * @author      SpryMedia Ltd (www.sprymedia.co.uk)
 * @contact     www.sprymedia.co.uk/contact
 * @copyright   Copyright 2015-2020 SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license/mit
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define(['jquery', 'datatables.net'], function ($) {
            return factory($, window, document);
        });
    }
    else if (typeof exports === 'object') {
        // CommonJS
        module.exports = function (root, $) {
            if (!root) {
                root = window;
            }

            if (!$ || !$.fn.dataTable) {
                $ = require('datatables.net')(root, $).$;
            }

            return factory($, root, root.document);
        };
    }
    else {
        // Browser
        factory(jQuery, window, document);
    }
}(function ($, window, document, undefined) {
    'use strict';
    var DataTable = $.fn.dataTable;


    /**
    * RowReorder provides the ability in DataTables to click and drag rows to
    * reorder them. When a row is dropped the data for the rows effected will be
    * updated to reflect the change. Normally this data point should also be the
    * column being sorted upon in the DataTable but this does not need to be the
    * case. RowReorder implements a "data swap" method - so the rows being
    * reordered take the value of the data point from the row that used to occupy
    * the row's new position.
    *
    * Initialisation is done by either:
    *
    * * `rowReorder` parameter in the DataTable initialisation object
    * * `new $.fn.dataTable.RowReorder( table, opts )` after DataTables
    *   initialisation.
    *
    *  @class
    *  @param {object} settings DataTables settings object for the host table
    *  @param {object} [opts] Configuration options
    *  @requires jQuery 1.7+
    *  @requires DataTables 1.10.7+
    */
    var RowReorder = function (dt, opts) {
        // Sanity check that we are using DataTables 1.10 or newer
        if (!DataTable.versionCheck || !DataTable.versionCheck('1.10.8')) {
            throw 'DataTables RowReorder requires DataTables 1.10.8 or newer';
        }

        // User and defaults configuration object
        this.c = $.extend(true, {},
            DataTable.defaults.rowReorder,
            RowReorder.defaults,
            opts
        );

        // Internal settings
        this.s = {
            /** @type {integer} Scroll body top cache */
            bodyTop: null,

            /** @type {DataTable.Api} DataTables' API instance */
            dt: new DataTable.Api(dt),

            /** @type {function} Data fetch function */
            getDataFn: DataTable.ext.oApi._fnGetObjectDataFn(this.c.dataSrc),

            /** @type {array} Pixel positions for row insertion calculation */
            middles: null,

            /** @type {Object} Cached dimension information for use in the mouse move event handler */
            scroll: {},

            /** @type {integer} Interval object used for smooth scrolling */
            scrollInterval: null,

            /** @type {function} Data set function */
            setDataFn: DataTable.ext.oApi._fnSetObjectDataFn(this.c.dataSrc),

            /** @type {Object} Mouse down information */
            start: {
                top: 0,
                left: 0,
                offsetTop: 0,
                offsetLeft: 0,
                nodes: []
            },

            /** @type {integer} Window height cached value */
            windowHeight: 0,

            /** @type {integer} Document outer height cached value */
            documentOuterHeight: 0,

            /** @type {integer} DOM clone outer height cached value */
            domCloneOuterHeight: 0
        };

        // DOM items
        this.dom = {
            /** @type {jQuery} Cloned row being moved around */
            clone: null,

            /** @type {jQuery} DataTables scrolling container */
            dtScroll: $('div.dataTables_scrollBody', this.s.dt.table().container())
        };

        // Check if row reorder has already been initialised on this table
        var settings = this.s.dt.settings()[0];
        var exisiting = settings.rowreorder;

        if (exisiting) {
            return exisiting;
        }

        if (!this.dom.dtScroll.length) {
            this.dom.dtScroll = $(this.s.dt.table().container(), 'tbody')
        }

        settings.rowreorder = this;
        this._constructor();
    };


    $.extend(RowReorder.prototype, {
        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        * Constructor
        */

        /**
        * Initialise the RowReorder instance
        *
        * @private
        */
        _constructor: function () {
            var that = this;
            var dt = this.s.dt;
            var table = $(dt.table().node());

            // Need to be able to calculate the row positions relative to the table
            if (table.css('position') === 'static') {
                table.css('position', 'relative');
            }

            // listen for mouse down on the target column - we have to implement
            // this rather than using HTML5 drag and drop as drag and drop doesn't
            // appear to work on table rows at this time. Also mobile browsers are
            // not supported.
            // Use `table().container()` rather than just the table node for IE8 -
            // otherwise it only works once...
            $(dt.table().container()).on('mousedown.rowReorder touchstart.rowReorder', this.c.selector, function (e) {
                if (!that.c.enable) {
                    return;
                }

                // Ignore excluded children of the selector
                if ($(e.target).is(that.c.excludedChildren)) {
                    return true;
                }

                var tr = $(this).closest('tr');
                var row = dt.row(tr);

                // Double check that it is a DataTable row
                if (row.any()) {
                    that._emitEvent('pre-row-reorder', {
                        node: row.node(),
                        index: row.index()
                    });

                    that._mouseDown(e, tr);
                    return false;
                }
            });

            dt.on('destroy.rowReorder', function () {
                $(dt.table().container()).off('.rowReorder');
                dt.off('.rowReorder');
            });
        },


        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        * Private methods
        */

        /**
        * Cache the measurements that RowReorder needs in the mouse move handler
        * to attempt to speed things up, rather than reading from the DOM.
        *
        * @private
        */
        _cachePositions: function () {
            var dt = this.s.dt;

            // Frustratingly, if we add `position:relative` to the tbody, the
            // position is still relatively to the parent. So we need to adjust
            // for that
            var headerHeight = $(dt.table().node()).find('thead').outerHeight();

            // Need to pass the nodes through jQuery to get them in document order,
            // not what DataTables thinks it is, since we have been altering the
            // order
            var nodes = $.unique(dt.rows({ page: 'current' }).nodes().toArray());
            var middles = $.map(nodes, function (node, i) {
                var top = $(node).position().top - headerHeight;

                return (top + top + $(node).outerHeight()) / 2;
            });

            this.s.middles = middles;
            this.s.bodyTop = $(dt.table().body()).offset().top;
            this.s.windowHeight = $(window).height();
            this.s.documentOuterHeight = $(document).outerHeight();
        },


        /**
        * Clone a row so it can be floated around the screen
        *
        * @param  {jQuery} target Node to be cloned
        * @private
        */
        _clone: function (target) {
            var dt = this.s.dt;
            var clone = $(dt.table().node().cloneNode(false))
                .addClass('dt-rowReorder-float')
                .append('<tbody/>')
                .append(target.clone(false));

            // Match the table and column widths - read all sizes before setting
            // to reduce reflows
            var tableWidth = target.outerWidth();
            var tableHeight = target.outerHeight();
            var sizes = target.children().map(function () {
                return $(this).width();
            });

            clone
                .width(tableWidth)
                .height(tableHeight)
                .find('tr').children().each(function (i) {
                    this.style.width = sizes[i] + 'px';
                });

            // Insert into the document to have it floating around
            clone.appendTo('body');

            this.dom.clone = clone;
            this.s.domCloneOuterHeight = clone.outerHeight();
        },


        /**
        * Update the cloned item's position in the document
        *
        * @param  {object} e Event giving the mouse's position
        * @private
        */
        _clonePosition: function (e) {
            var start = this.s.start;
            var topDiff = this._eventToPage(e, 'Y') - start.top;
            var leftDiff = this._eventToPage(e, 'X') - start.left;
            var snap = this.c.snapX;
            var left;
            var top = topDiff + start.offsetTop;

            if (snap === true) {
                left = start.offsetLeft;
            }
            else if (typeof snap === 'number') {
                left = start.offsetLeft + snap;
            }
            else {
                left = leftDiff + start.offsetLeft;
            }

            if (top < 0) {
                top = 0
            }
            else if (top + this.s.domCloneOuterHeight > this.s.documentOuterHeight) {
                top = this.s.documentOuterHeight - this.s.domCloneOuterHeight;
            }

            this.dom.clone.css({
                top: top,
                left: left
            });
        },


        /**
        * Emit an event on the DataTable for listeners
        *
        * @param  {string} name Event name
        * @param  {array} args Event arguments
        * @private
        */
        _emitEvent: function (name, args) {
            this.s.dt.iterator('table', function (ctx, i) {
                $(ctx.nTable).triggerHandler(name + '.dt', args);
            });
        },


        /**
        * Get pageX/Y position from an event, regardless of if it is a mouse or
        * touch event.
        *
        * @param  {object} e Event
        * @param  {string} pos X or Y (must be a capital)
        * @private
        */
        _eventToPage: function (e, pos) {
            if (e.type.indexOf('touch') !== -1) {
                return e.originalEvent.touches[0]['page' + pos];
            }

            return e['page' + pos];
        },


        /**
        * Mouse down event handler. Read initial positions and add event handlers
        * for the move.
        *
        * @param  {object} e      Mouse event
        * @param  {jQuery} target TR element that is to be moved
        * @private
        */
        _mouseDown: function (e, target) {
            var that = this;
            var dt = this.s.dt;
            var start = this.s.start;

            var offset = target.offset();
            start.top = this._eventToPage(e, 'Y');
            start.left = this._eventToPage(e, 'X');
            start.offsetTop = offset.top;
            start.offsetLeft = offset.left;
            start.nodes = $.unique(dt.rows({ page: 'current' }).nodes().toArray());

            this._cachePositions();
            this._clone(target);
            this._clonePosition(e);

            this.dom.target = target;
            target.addClass('dt-rowReorder-moving');

            $(document)
                .on('mouseup.rowReorder touchend.rowReorder', function (e) {
                    that._mouseUp(e);
                })
                .on('mousemove.rowReorder touchmove.rowReorder', function (e) {
                    that._mouseMove(e);
                });

            // Check if window is x-scrolling - if not, disable it for the duration
            // of the drag
            if ($(window).width() === $(document).width()) {
                $(document.body).addClass('dt-rowReorder-noOverflow');
            }

            // Cache scrolling information so mouse move doesn't need to read.
            // This assumes that the window and DT scroller will not change size
            // during an row drag, which I think is a fair assumption
            var scrollWrapper = this.dom.dtScroll;
            this.s.scroll = {
                windowHeight: $(window).height(),
                windowWidth: $(window).width(),
                dtTop: scrollWrapper.length ? scrollWrapper.offset().top : null,
                dtLeft: scrollWrapper.length ? scrollWrapper.offset().left : null,
                dtHeight: scrollWrapper.length ? scrollWrapper.outerHeight() : null,
                dtWidth: scrollWrapper.length ? scrollWrapper.outerWidth() : null
            };
        },


        /**
        * Mouse move event handler - move the cloned row and shuffle the table's
        * rows if required.
        *
        * @param  {object} e Mouse event
        * @private
        */
        _mouseMove: function (e) {
            this._clonePosition(e);

            // Transform the mouse position into a position in the table's body
            var bodyY = this._eventToPage(e, 'Y') - this.s.bodyTop;
            var middles = this.s.middles;
            var insertPoint = null;
            var dt = this.s.dt;

            // Determine where the row should be inserted based on the mouse
            // position
            for (var i = 0, ien = middles.length; i < ien; i++) {
                if (bodyY < middles[i]) {
                    insertPoint = i;
                    break;
                }
            }

            if (insertPoint === null) {
                insertPoint = middles.length;
            }

            // Perform the DOM shuffle if it has changed from last time
            if (this.s.lastInsert === null || this.s.lastInsert !== insertPoint) {
                var nodes = $.unique(dt.rows({ page: 'current' }).nodes().toArray());

                if (insertPoint > this.s.lastInsert) {
                    this.dom.target.insertAfter(nodes[insertPoint - 1]);
                }
                else {
                    this.dom.target.insertBefore(nodes[insertPoint]);
                }

                this._cachePositions();

                this.s.lastInsert = insertPoint;
            }

            this._shiftScroll(e);
        },


        /**
        * Mouse up event handler - release the event handlers and perform the
        * table updates
        *
        * @param  {object} e Mouse event
        * @private
        */
        _mouseUp: function (e) {
            var that = this;
            var dt = this.s.dt;
            var i, ien;
            var dataSrc = this.c.dataSrc;

            this.dom.clone.remove();
            this.dom.clone = null;

            this.dom.target.removeClass('dt-rowReorder-moving');
            //this.dom.target = null;

            $(document).off('.rowReorder');
            $(document.body).removeClass('dt-rowReorder-noOverflow');

            clearInterval(this.s.scrollInterval);
            this.s.scrollInterval = null;

            // Calculate the difference
            var startNodes = this.s.start.nodes;
            var endNodes = $.unique(dt.rows({ page: 'current' }).nodes().toArray());
            var idDiff = {};
            var fullDiff = [];
            var diffNodes = [];
            var getDataFn = this.s.getDataFn;
            var setDataFn = this.s.setDataFn;

            for (i = 0, ien = startNodes.length; i < ien; i++) {
                if (startNodes[i] !== endNodes[i]) {
                    var id = dt.row(endNodes[i]).id();
                    var endRowData = dt.row(endNodes[i]).data();
                    var startRowData = dt.row(startNodes[i]).data();

                    if (id) {
                        idDiff[id] = getDataFn(startRowData);
                    }

                    fullDiff.push({
                        node: endNodes[i],
                        oldData: getDataFn(endRowData),
                        newData: getDataFn(startRowData),
                        newPosition: i,
                        oldPosition: $.inArray(endNodes[i], startNodes)
                    });

                    diffNodes.push(endNodes[i]);
                }
            }

            // Create event args
            var eventArgs = [fullDiff, {
                dataSrc: dataSrc,
                nodes: diffNodes,
                values: idDiff,
                triggerRow: dt.row(this.dom.target),
                originalEvent: e
            }];

            // Emit event
            this._emitEvent('row-reorder', eventArgs);
            ///////////////////////////////////////////////////////////////////////
            ///////////////////////////////////////////////////////////////////////
            ///////////////////////////////////////////////////////////////////////
            ///////////////////////////////////////////////////////////////////////
            ///////////////////////////////////////////////////////////////////////
            ///////////////////////////////////////////////////////////////////////
            ///////////////////////////////////////////////////////////////////////
            if (this.c.reorderUpdate) {

                var update = function () {
                    if (that.c.update) {
                        for (i = 0, ien = fullDiff.length; i < ien; i++) {
                            var row = dt.row(fullDiff[i].node);
                            var rowData = row.data();

                            setDataFn(rowData, fullDiff[i].newData);

                            // Invalidate the cell that has the same data source as the dataSrc
                            dt.columns().every(function () {
                                if (this.dataSrc() === dataSrc) {
                                    dt.cell(fullDiff[i].node, this.index()).invalidate('data');
                                }
                            });
                        }

                        // Trigger row reordered event
                        that._emitEvent('row-reordered', eventArgs);

                        dt.draw(false);
                    }
                };
            }

            //// Editor interface
            //if (this.c.editor) {
            // // Disable user interaction while Editor is submitting
            // this.c.enable = false;

            // this.c.editor
            // .edit(
            // diffNodes,
            // false,
            // $.extend({ submit: 'changed' }, this.c.formOptions)
            // )
            // .multiSet(dataSrc, idDiff)
            // .one('preSubmitCancelled.rowReorder', function () {
            // that.c.enable = true;
            // that.c.editor.off('.rowReorder');
            // dt.draw(false);
            // })
            // .one('submitUnsuccessful.rowReorder', function () {
            // dt.draw(false);
            // })
            // .one('submitSuccess.rowReorder', function () {
            // update();
            // })
            // .one('submitComplete', function () {
            // that.c.enable = true;
            // that.c.editor.off('.rowReorder');
            // })
            // .submit();
            //}
            //else {
            // update();
            //}
        },


        /**
        * Move the window and DataTables scrolling during a drag to scroll new
        * content into view.
        *
        * This matches the `_shiftScroll` method used in AutoFill, but only
        * horizontal scrolling is considered here.
        *
        * @param  {object} e Mouse move event object
        * @private
        */
        _shiftScroll: function (e) {
            var that = this;
            var dt = this.s.dt;
            var scroll = this.s.scroll;
            var runInterval = false;
            var scrollSpeed = 5;
            var buffer = 65;
            var
                windowY = e.pageY - document.body.scrollTop,
                windowVert,
                dtVert;

            // Window calculations - based on the mouse position in the window,
            // regardless of scrolling
            if (windowY < $(window).scrollTop() + buffer) {
                windowVert = scrollSpeed * -1;
            }
            else if (windowY > scroll.windowHeight + $(window).scrollTop() - buffer) {
                windowVert = scrollSpeed;
            }

            // DataTables scrolling calculations - based on the table's position in
            // the document and the mouse position on the page
            if (scroll.dtTop !== null && e.pageY < scroll.dtTop + buffer) {
                dtVert = scrollSpeed * -1;
            }
            else if (scroll.dtTop !== null && e.pageY > scroll.dtTop + scroll.dtHeight - buffer) {
                dtVert = scrollSpeed;
            }

            // This is where it gets interesting. We want to continue scrolling
            // without requiring a mouse move, so we need an interval to be
            // triggered. The interval should continue until it is no longer needed,
            // but it must also use the latest scroll commands (for example consider
            // that the mouse might move from scrolling up to scrolling left, all
            // with the same interval running. We use the `scroll` object to "pass"
            // this information to the interval. Can't use local variables as they
            // wouldn't be the ones that are used by an already existing interval!
            if (windowVert || dtVert) {
                scroll.windowVert = windowVert;
                scroll.dtVert = dtVert;
                runInterval = true;
            }
            else if (this.s.scrollInterval) {
                // Don't need to scroll - remove any existing timer
                clearInterval(this.s.scrollInterval);
                this.s.scrollInterval = null;
            }

            // If we need to run the interval to scroll and there is no existing
            // interval (if there is an existing one, it will continue to run)
            if (!this.s.scrollInterval && runInterval) {
                this.s.scrollInterval = setInterval(function () {
                    // Don't need to worry about setting scroll <0 or beyond the
                    // scroll bound as the browser will just reject that.
                    if (scroll.windowVert) {
                        var top = $(document).scrollTop();
                        $(document).scrollTop(top + scroll.windowVert);

                        if (top !== $(document).scrollTop()) {
                            var move = parseFloat(that.dom.clone.css("top"));
                            that.dom.clone.css("top", move + scroll.windowVert);
                        }
                    }

                    // DataTables scrolling
                    if (scroll.dtVert) {
                        var scroller = that.dom.dtScroll[0];

                        if (scroll.dtVert) {
                            scroller.scrollTop += scroll.dtVert;
                        }
                    }
                }, 20);
            }
        }
    });



    /**
    * RowReorder default settings for initialisation
    *
    * @namespace
    * @name RowReorder.defaults
    * @static
    */
    RowReorder.defaults = {
        reorderUpdate: true,
        /**
        * Data point in the host row's data source object for where to get and set
        * the data to reorder. This will normally also be the sorting column.
        *
        * @type {Number}
        */
        dataSrc: 0,

        /**
        * Editor instance that will be used to perform the update
        *
        * @type {DataTable.Editor}
        */
        editor: null,

        /**
        * Enable / disable RowReorder's user interaction
        * @type {Boolean}
        */
        enable: true,

        /**
        * Form options to pass to Editor when submitting a change in the row order.
        * See the Editor `from-options` object for details of the options
        * available.
        * @type {Object}
        */
        formOptions: {},

        /**
        * Drag handle selector. This defines the element that when dragged will
        * reorder a row.
        *
        * @type {String}
        */
        selector: 'td:first-child',

        /**
        * Optionally lock the dragged row's x-position. This can be `true` to
        * fix the position match the host table's, `false` to allow free movement
        * of the row, or a number to define an offset from the host table.
        *
        * @type {Boolean|number}
        */
        snapX: false,

        /**
        * Update the table's data on drop
        *
        * @type {Boolean}
        */
        update: true,

        /**
        * Selector for children of the drag handle selector that mouseDown events
        * will be passed through to and drag will not activate
        *
        * @type {String}
        */
        excludedChildren: 'a'
    };


    /*
    * API
    */
    var Api = $.fn.dataTable.Api;

    // Doesn't do anything - work around for a bug in DT... Not documented
    Api.register('rowReorder()', function () {
        return this;
    });

    Api.register('rowReorder.enable()', function (toggle) {
        if (toggle === undefined) {
            toggle = true;
        }

        return this.iterator('table', function (ctx) {
            if (ctx.rowreorder) {
                ctx.rowreorder.c.enable = toggle;
            }
        });
    });

    Api.register('rowReorder.disable()', function () {
        return this.iterator('table', function (ctx) {
            if (ctx.rowreorder) {
                ctx.rowreorder.c.enable = false;
            }
        });
    });



    /**
    * Version information
    *
    * @name RowReorder.version
    * @static
    */
    RowReorder.version = '1.2.6';


    $.fn.dataTable.RowReorder = RowReorder;
    $.fn.DataTable.RowReorder = RowReorder;

    // Attach a listener to the document which listens for DataTables initialisation
    // events so we can automatically initialise
    $(document).on('init.dt.dtr', function (e, settings, json) {
        if (e.namespace !== 'dt') {
            return;
        }

        var init = settings.oInit.rowReorder;
        var defaults = DataTable.defaults.rowReorder;

        if (init || defaults) {
            var opts = $.extend({}, init, defaults);

            if (init !== false) {
                new RowReorder(settings, opts);
            }
        }
    });


    return RowReorder;
}));




//*******************************************************************************
///*!
// RowReorder 1.2.0
// 2015-2016 SpryMedia Ltd - datatables.net/license
//*/
//(function(e){"function"===typeof define&&define.amd?define(["jquery","datatables.net"],function(f){return e(f,window,document)}):"object"===typeof exports?module.exports=function(f,g){f||(f=window);if(!g||!g.fn.dataTable)g=require("datatables.net")(f,g).$;return e(g,f,f.document)}:e(jQuery,window,document)})(function(e,f,g,n){var l=e.fn.dataTable,j=function(c,b){if(!l.versionCheck||!l.versionCheck("1.10.8"))throw"DataTables RowReorder requires DataTables 1.10.8 or newer";this.c=e.extend(!0,{},l.defaults.rowReorder,
//j.defaults,b);this.s={bodyTop:null,dt:new l.Api(c),getDataFn:l.ext.oApi._fnGetObjectDataFn(this.c.dataSrc),middles:null,scroll:{},scrollInterval:null,setDataFn:l.ext.oApi._fnSetObjectDataFn(this.c.dataSrc),start:{top:0,left:0,offsetTop:0,offsetLeft:0,nodes:[]},windowHeight:0};this.dom={clone:null,dtScroll:e("div.dataTables_scrollBody",this.s.dt.table().container())};var a=this.s.dt.settings()[0],d=a.rowreorder;if(d)return d;a.rowreorder=this;this._constructor()};e.extend(j.prototype,{_constructor:function(){var c=
//this,b=this.s.dt,a=e(b.table().node());"static"===a.css("position")&&a.css("position","relative");e(b.table().container()).on("mousedown.rowReorder touchstart.rowReorder",this.c.selector,function(a){if(c.c.enabled){var h=e(this).closest("tr");if(b.row(h).any())return c._mouseDown(a,h),!1}});b.on("destroy.rowReorder",function(){e(b.table().container()).off(".rowReorder");b.off(".rowReorder")})},_cachePositions:function(){var c=this.s.dt,b=e(c.table().node()).find("thead").outerHeight(),a=e.unique(c.rows({page:"current"}).nodes().toArray()),
//d=e.map(a,function(a){return e(a).position().top-b}),a=e.map(d,function(a,b){return d.length<b-1?(a+d[b+1])/2:(a+a+e(c.row(":last-child").node()).outerHeight())/2});this.s.middles=a;this.s.bodyTop=e(c.table().body()).offset().top;this.s.windowHeight=e(f).height()},_clone:function(c){var b=e(this.s.dt.table().node().cloneNode(!1)).addClass("dt-rowReorder-float").append("<tbody/>").append(c.clone(!1)),a=c.outerWidth(),d=c.outerHeight(),h=c.children().map(function(){return e(this).width()});b.width(a).height(d).find("tr").children().each(function(a){this.style.width=
//h[a]+"px"});b.appendTo("body");this.dom.clone=b},_clonePosition:function(c){var b=this.s.start,a=this._eventToPage(c,"Y")-b.top,c=this._eventToPage(c,"X")-b.left,d=this.c.snapX;this.dom.clone.css({top:a+b.offsetTop,left:!0===d?b.offsetLeft:"number"===typeof d?b.offsetLeft+d:c+b.offsetLeft})},_emitEvent:function(c,b){this.s.dt.iterator("table",function(a){e(a.nTable).triggerHandler(c+".dt",b)})},_eventToPage:function(c,b){return-1!==c.type.indexOf("touch")?c.originalEvent.touches[0]["page"+b]:c["page"+
//b]},_mouseDown:function(c,b){var a=this,d=this.s.dt,h=this.s.start,k=b.offset();h.top=this._eventToPage(c,"Y");h.left=this._eventToPage(c,"X");h.offsetTop=k.top;h.offsetLeft=k.left;h.nodes=e.unique(d.rows({page:"current"}).nodes().toArray());this._cachePositions();this._clone(b);this._clonePosition(c);this.dom.target=b;b.addClass("dt-rowReorder-moving");e(g).on("mouseup.rowReorder touchend.rowReorder",function(b){a._mouseUp(b)}).on("mousemove.rowReorder touchmove.rowReorder",function(b){a._mouseMove(b)});
//e(f).width()===e(g).width()&&e(g.body).addClass("dt-rowReorder-noOverflow");d=this.dom.dtScroll;this.s.scroll={windowHeight:e(f).height(),windowWidth:e(f).width(),dtTop:d.length?d.offset().top:null,dtLeft:d.length?d.offset().left:null,dtHeight:d.length?d.outerHeight():null,dtWidth:d.length?d.outerWidth():null}},_mouseMove:function(c){this._clonePosition(c);for(var b=this._eventToPage(c,"Y")-this.s.bodyTop,a=this.s.middles,d=null,h=this.s.dt,k=h.table().body(),i=0,g=a.length;i<g;i++)if(b<a[i]){d=i;
//break}null===d&&(d=a.length);if(null===this.s.lastInsert||this.s.lastInsert!==d)0===d?this.dom.target.prependTo(k):(b=e.unique(h.rows({page:"current"}).nodes().toArray()),d>this.s.lastInsert?this.dom.target.insertAfter(b[d-1]):this.dom.target.insertBefore(b[d])),this._cachePositions(),this.s.lastInsert=d;this._shiftScroll(c)},_mouseUp:function(){var c=this,b=this.s.dt,a,d,h=this.c.dataSrc;this.dom.clone.remove();this.dom.clone=null;this.dom.target.removeClass("dt-rowReorder-moving");e(g).off(".rowReorder");
//e(g.body).removeClass("dt-rowReorder-noOverflow");clearInterval(this.s.scrollInterval);this.s.scrollInterval=null;var k=this.s.start.nodes,i=e.unique(b.rows({page:"current"}).nodes().toArray()),f={},j=[],l=[],m=this.s.getDataFn,n=this.s.setDataFn;a=0;for(d=k.length;a<d;a++)if(k[a]!==i[a]){var o=b.row(i[a]).id(),q=b.row(i[a]).data(),p=b.row(k[a]).data();o&&(f[o]=m(p));j.push({node:i[a],oldData:m(q),newData:m(p),newPosition:a,oldPosition:e.inArray(i[a],k)});l.push(i[a])}k=[j,{dataSrc:h,nodes:l,values:f,
//triggerRow:b.row(this.dom.target)}];this._emitEvent("row-reorder",k);this.c.editor&&(this.c.enabled=!1,this.c.editor.edit(l,!1,e.extend({submit:"changed"},this.c.formOptions)).multiSet(h,f).one("submitComplete",function(){c.c.enabled=!0}).submit());if(this.c.update){a=0;for(d=j.length;a<d;a++)f=b.row(j[a].node).data(),n(f,j[a].newData),b.columns().every(function(){this.dataSrc()===h&&b.cell(j[a].node,this.index()).invalidate("data")});this._emitEvent("row-reordered",k);b.draw(!1)}},_shiftScroll:function(c){var b=
//this,a=this.s.scroll,d=!1,e=c.pageY-g.body.scrollTop,f,i;65>e?f=-5:e>a.windowHeight-65&&(f=5);null!==a.dtTop&&c.pageY<a.dtTop+65?i=-5:null!==a.dtTop&&c.pageY>a.dtTop+a.dtHeight-65&&(i=5);f||i?(a.windowVert=f,a.dtVert=i,d=!0):this.s.scrollInterval&&(clearInterval(this.s.scrollInterval),this.s.scrollInterval=null);!this.s.scrollInterval&&d&&(this.s.scrollInterval=setInterval(function(){if(a.windowVert)g.body.scrollTop=g.body.scrollTop+a.windowVert;if(a.dtVert){var c=b.dom.dtScroll[0];if(a.dtVert)c.scrollTop=
//c.scrollTop+a.dtVert}},20))}});j.defaults={dataSrc:0,editor:null,enabled:!0,formOptions:{},selector:"td:first-child",snapX:!1,update:!0};var m=e.fn.dataTable.Api;m.register("rowReorder()",function(){return this});m.register("rowReorder.enable()",function(c){c===n&&(c=!0);return this.iterator("table",function(b){b.rowreorder&&(b.rowreorder.c.enabled=c)})});m.register("rowReorder.disable()",function(){return this.iterator("table",function(c){c.rowreorder&&(c.rowreorder.c.enabled=!1)})});j.version="1.2.0";
//e.fn.dataTable.RowReorder=j;e.fn.DataTable.RowReorder=j;e(g).on("init.dt.dtr",function(c,b){if("dt"===c.namespace){var a=b.oInit.rowReorder,d=l.defaults.rowReorder;if(a||d)d=e.extend({},a,d),!1!==a&&new j(b,d)}});return j});